#!/bin/bash
#
# Dependancies:
#
#       bash
#       tmux
#       dirname
#       tail
#       xxd
#
#
# Side effects:
#
#   -   One log file in the same directory as this script
#
#   -   `./keylogger start` changes tmux key bindings
#
#
# Note:
#
#   -   If your tmux window width is too small the status message
#       will not be able to be correctly displayed.
#
#   -   Currently only one-byte ASCII keystrokes are
#       supported, because most of the time we are entering
#       these characters and it's pretty to handle in tmux.
#
#       Other keystrokes like the meta keys (e.g. M-b) will not
#       be logged if you do not press the ^[ key manually.
#
#   -   Please do not leave the keylogger.log file too large.
#       That may make this script slower...
#
#   -   This script is not well tested under various circumstances.
#       Maybe it might break something but I haven't noticed
#

declare -r KL_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P);
declare -r LOG_FILE=$KL_DIR/keylogger.log;
declare -r ONE_ASCII_HEX='^[0-7][0-9a-fA-F]+$';
declare -r ONE_ASCII_DEC='^([0-9]|[1-9][0-9]|1[01][0-9]|12[0-7])$';
declare -r MAX_NBYTES=60
declare -r MAX_NCOLUMNS=30

function kl_dec2hex () {
        [[ $* =~ $ONE_ASCII_DEC ]] || return 1;
        printf %02x "$*";
};

function kl_hex2dec () {
        [[ $* =~ $ONE_ASCII_HEX ]] || return 1;
        printf %d 0x"$*";
};

function kl_hex2raw () {
        [[ $* =~ $ONE_ASCII_HEX ]] || return 1;
        printf "\x$*";
};

function kl_build_callback_cmdstring () {
        declare callback_cmd;
        callback_cmd+="tmux set-option status-right '";
        callback_cmd+=$1;
        callback_cmd+="' >/dev/null 2>&1 &";
        printf %s "$callback_cmd";
};

function kl_rebind_ascii_key () {
        declare callback_cmd=$(kl_build_callback_cmdstring $1);
        tmux bind-key -n "$3" send-keys "$2" '\;' run-shell "$callback_cmd";
};

function kl_rebind_prefix_key () {
        declare callback_cmd=$(kl_build_callback_cmdstring $1);
        tmux bind-key C-$2 send-prefix '\;' run-shell "$callback_cmd";
};

function kl_patch_all_ascii_keystroke () {
        declare counter;
        declare head;
        declare tail=$table;
        declare tuple hexdigits sendliteral bindliteral;
        for (( counter = 0 ; counter < 128 ; counter ++ )); do
                head=${tail%%$'\n'|*};
                tail=${tail#|*|$'\n'};

                tuple=$head;
                tuple=${tuple#??};
                tuple=${tuple%?};
                {
                        IFS= read -r -d $'\t' hexdigits;
                        IFS= read -r -d $'\t' sendliteral;
                        IFS= read -r -d $'\t' bindliteral;
                } <<< "$tuple";

                kl_rebind_ascii_key "$hexdigits" "$sendliteral" "$bindliteral";
        done;
};

function kl_patch_send_prefix_key () {
        declare quicklookup tmpstr re target lookup result;
        quicklookup+=' a01 b02 c03 d04 e05 f06 g07 h08 i09 j0a k0b l0c m0d';
        quicklookup+=' n0e o0f p10 q11 r12 s13 t14 u15 v16 w17 x18 y19 z1a';
        tmpstr=$(printf %s $(tmux list-keys | grep -m 1 send-prefix || :));
        if [[ $tmpstr = '' ]]; then
                echo 'Notice: Currently no send-prefix key binding is found.';
        else
                tmpstr=${tmpstr%send-prefix};
                tmpstr=${tmpstr#bind-keyC-};
                re='^[a-z]$';
                if [[ $tmpstr =~ $re ]]; then
                        target=$tmpstr;
                        lookup=${quicklookup##* $target};
                        result=${lookup:0:2};
                        kl_rebind_prefix_key "$result" "$target";
                else
                        echo 'Please check if your send-prefix works.';
                fi;
        fi;
};

function kl_patch_all_tmux_options () {
        kl_patch_all_ascii_keystroke;
        kl_patch_send_prefix_key;
        tmux set-option status on                           >/dev/null;
        tmux set-option status-right ''                     >/dev/null;
        tmux set-option status-right-length 60              >/dev/null;
        tmux set-option status-left  ''                     >/dev/null;
        tmux set-option -g window-status-format ''          >/dev/null;
        tmux set-option -g window-status-current-format ''  >/dev/null;
};

function kl_log_history_add () {
        kl_hex2raw $1 >> "$LOG_FILE";
};

function kl_log_history_get () {
        [[ -e "$LOG_FILE" ]] || return 0;
        [[ -f "$LOG_FILE" ]] || return 1;

        declare logtail=$(tail -c "$MAX_NBYTES" "$LOG_FILE" | xxd -c 1 -p);
        printf '%s' "$logtail";
        : ' If you just typed "test" and "^U^X^C" ';
        : ' this will print out something like:   ';
        : '                                       ';
        : '      74           <-- t               ';
        : '      65           <-- e               ';
        : '      73           <-- s               ';
        : '      74           <-- t               ';
        : '      15           <-- ^U              ';
        : '      18           <-- ^X              ';
        : '      16           <-- ^C   (latest)   ';
        : '                                       ';
        : ' Each line contains two hex digits     ';
};

function kl_log_update_view () {
        declare -i i;
        declare -i n_bytes=0;
        declare -a array_of_bytes=(); : 'Last keystroke first';

        while read byte_in_hh; do
                (( n_bytes += 1 ));
                (( i = MAX_NBYTES - n_bytes ));
                array_of_bytes[$i]=$byte_in_hh;
        done < <(kl_log_history_get);

        : ' n_bytes=7                             ';
        : ' array_of_bytes=( ... )                ';
        : '                                       ';
        : '     [0]=""                            ';
        : '     [1]=""                            ';
        : '     [2]=""                            ';
        : '     [3]="16"      <-- ^C   (latest)   ';
        : '     [4]="18"      <-- ^X              ';
        : '     [5]="15"      <-- ^U              ';
        : '     [6]="74"      <-- t               ';
        : '     [7]="73"      <-- s               ';
        : '     [8]="65"      <-- e               ';
        : '     [9]="74"      <-- t               ';
        : '                                       ';

        : 'TODO';
        : 'Compute the last M bytes that fits into the status bar';
        : 'Each byte may have different number of columns when displayed';

        : 'TODO';
        : 'Encode the bytes into readable characters';
        : '(two letter ctrl characters need color)';
        : '(# need to be encoded as ## for tmux)';

        : 'TODO';
        : 'Update the tmux status-message here';
};

function kl_log_key () {
        [[ $# = 1 ]] || return 1;

        kl_log_history_add $1;
        kl_log_update_view;

        : 'After this function is done, update kl_build_callback_cmdstring';
        printf '%s\n' "[DEBUG] The input to kl_log_key is '$1'";
};

function kl_main () {
        if [[ $# = 2 && $1 = - ]]; then
                kl_log_key $2;
                return;
        fi;

        if [[ $# = 1 && $1 = start ]]; then
                if [[ ${TMUX:-} = '' ]]; then
                        printf '%s\n' 'Please run the command inside tmux';
                        return 1;
                fi;
                kl_patch_all_tmux_options;
                return;
        fi;

        printf 'Usage:\n';
        printf '\t%s\n' "keylogger start";
        printf '\t%s\n' "keylogger - <hexvalue>";
        printf '\n';
        printf 'Example:\n';
        printf '\t%s\n' "Start logging in tmux:  ./keylogger start";
        printf '\t%s\n' "Log the keystroke 'h':  ./keylogger - 68";
        printf '\t%s\n' "                       ('h' == 104 == 0x68)";
        printf '\n';
        return 1;
};

declare table;

: ' This works because the standard input data from ';
: ' this here document block does not contain any   ';
: ' character of the byte value 0x11 (i.e. the ^Q)  ';

{ IFS= read -r -d $'\x11' table || :; } <<'END_STD_INPUT'
|	00	^@	C-Space	|
|	01	^A	C-a	|
|	02	^B	C-b	|
|	03	^C	C-c	|
|	04	^D	C-d	|
|	05	^E	C-e	|
|	06	^F	C-f	|
|	07	^G	C-g	|
|	08	^H	C-h	|
|	09	^I	C-i	|
|	0a	^J	C-j	|
|	0b	^K	C-k	|
|	0c	^L	C-l	|
|	0d	^M	C-m	|
|	0e	^N	C-n	|
|	0f	^O	C-o	|
|	10	^P	C-p	|
|	11	^Q	C-q	|
|	12	^R	C-r	|
|	13	^S	C-s	|
|	14	^T	C-t	|
|	15	^U	C-u	|
|	16	^V	C-v	|
|	17	^W	C-w	|
|	18	^X	C-x	|
|	19	^Y	C-y	|
|	1a	^Z	C-z	|
|	1b	^[	C-[	|
|	1c	^\	C-\	|
|	1d	^]	C-]	|
|	1e	^^	C-^	|
|	1f	^_	C-_	|
|	20	 	 	|
|	21	!	!	|
|	22	"	"	|
|	23	#	#	|
|	24	$	$	|
|	25	%	%	|
|	26	&	&	|
|	27	'	'	|
|	28	(	(	|
|	29	)	)	|
|	2a	*	*	|
|	2b	+	+	|
|	2c	,	,	|
|	2d	-	-	|
|	2e	.	.	|
|	2f	/	/	|
|	30	0	0	|
|	31	1	1	|
|	32	2	2	|
|	33	3	3	|
|	34	4	4	|
|	35	5	5	|
|	36	6	6	|
|	37	7	7	|
|	38	8	8	|
|	39	9	9	|
|	3a	:	:	|
|	3b	\\;	\;	|
|	3c	<	<	|
|	3d	=	=	|
|	3e	>	>	|
|	3f	?	?	|
|	40	@	@	|
|	41	A	A	|
|	42	B	B	|
|	43	C	C	|
|	44	D	D	|
|	45	E	E	|
|	46	F	F	|
|	47	G	G	|
|	48	H	H	|
|	49	I	I	|
|	4a	J	J	|
|	4b	K	K	|
|	4c	L	L	|
|	4d	M	M	|
|	4e	N	N	|
|	4f	O	O	|
|	50	P	P	|
|	51	Q	Q	|
|	52	R	R	|
|	53	S	S	|
|	54	T	T	|
|	55	U	U	|
|	56	V	V	|
|	57	W	W	|
|	58	X	X	|
|	59	Y	Y	|
|	5a	Z	Z	|
|	5b	[	[	|
|	5c	\	\	|
|	5d	]	]	|
|	5e	^	^	|
|	5f	_	_	|
|	60	`	`	|
|	61	a	a	|
|	62	b	b	|
|	63	c	c	|
|	64	d	d	|
|	65	e	e	|
|	66	f	f	|
|	67	g	g	|
|	68	h	h	|
|	69	i	i	|
|	6a	j	j	|
|	6b	k	k	|
|	6c	l	l	|
|	6d	m	m	|
|	6e	n	n	|
|	6f	o	o	|
|	70	p	p	|
|	71	q	q	|
|	72	r	r	|
|	73	s	s	|
|	74	t	t	|
|	75	u	u	|
|	76	v	v	|
|	77	w	w	|
|	78	x	x	|
|	79	y	y	|
|	7a	z	z	|
|	7b	{	{	|
|	7c	|	|	|
|	7d	}	}	|
|	7e	~	~	|
|	7f	Bspace	BSpace	|
|
END_STD_INPUT

if [[ ${BASH_SOURCE[0]} != $0 ]]; then
        : 'The script is sourced';
        : 'Do not do anything here';
else
        : 'The script is executed';
        : 'Invoke the main procedure now';
        set -e;
        set -u;
        kl_main "$@";
fi;

# vi: se et sta ts=8 sw=8 sts=2 :
